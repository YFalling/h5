var songContent = '[00:01.56]Blooming Lily\n [00:15.23]因為所能回憶起來的事情一個也沒有\n [00:21.63]才像跑出去旅行的流浪貓一樣\n [00:28.80]其實我想抱緊你這個最了解我的人\n [00:41.60]那一天我為何\n [00:44.39]竟把手鬆開了\n [00:48.29]那遙遠的秘密基地\n [00:51.47]想要把全部的事情給\n [00:54.98]重新再來一次\n [00:58.17]但是我仍不會原諒你\n [01:02.23]因為已經失去了\n [01:05.54]那兩人所一起描繪的那樣的未來的藍圖\n [01:11.75]已經沒法說出居所之類的的了\n [01:15.67]似乎讓你看到了我的弱小\n [01:19.04]百合(梨梨)的花正高傲地綻放著\n [01:38.04]故意選擇了較遠的路\n [01:44.44]只為了得到可以獲得經驗的寶物\n [01:51.59]為了將這極想承認的存在\n [01:57.94]給忘掉好像下了一番努力呢\n [02:04.36]這孩子氣的夢想\n [02:07.13]就像笨蛋一樣\n [02:11.04]而這麼奇怪的人\n [02:14.25]已經到處都找不到了喲\n [02:17.89]你耀眼到令我討厭\n [02:22.73]在朋友以上的距離\n [02:26.61]就這樣被放置了喲\n [02:30.05]如果不變的更強的話就沒辦法開始了喲\n [02:36.37]在戀人未滿的位置\n [02:40.17]一直地注視著你喲\n [02:43.52]總有一天會找到心的鑰匙的\n [03:15.13]但是我仍不會原諒你\n [03:19.03]也不會說出「喜歡你」\n [03:22.46]更不會說你是對我來說最重視或最特別的\n [03:28.56]再一次去去看吧\n [03:32.60]那我們兩人的秘密基地\n [03:35.95]百合(梨梨)的花歡迎你的物語\n [03:42.87]百合(梨梨)的花和你寫的物語\n'
var songContent1 = '' ;
function parseLyric(text) {
    //将文本分隔成一行一行，存入数组
    var lines = text.split('\n'),
        //用于匹配时间的正则表达式，匹配的结果类似[xx:xx.xx]
        pattern = /\[\d{2}:\d{2}.\d{2}\]/g,
        //保存最终结果的数组
        result = [];
    //去掉不含时间的行
    while (!pattern.test(lines[0])) {
        lines = lines.slice(1);
    };
    //上面用'\n'生成生成数组时，结果中最后一个为空元素，这里将去掉
    lines[lines.length - 1].length === 0 && lines.pop();
    lines.forEach(function(v /*数组元素值*/ , i /*元素索引*/ , a /*数组本身*/ ) {
        //提取出时间[xx:xx.xx]
        var time = v.match(pattern),
            //提取歌词
            value = v.replace(pattern, '');
        //因为一行里面可能有多个时间，所以time有可能是[xx:xx.xx][xx:xx.xx][xx:xx.xx]的形式，需要进一步分隔
        time.forEach(function(v1, i1, a1) {
            //去掉时间里的中括号得到xx:xx.xx
            var t = v1.slice(1, -1).split(':');
            //将结果压入最终数组
            result.push([parseInt(t[0], 10) * 60 + parseFloat(t[1]), value]);
        });
    });
    //最后将结果数组中的元素按时间大小排序，以便保存之后正常显示歌词
    result.sort(function(a, b) {
        return a[0] - b[0];
    });
    return result;
}

